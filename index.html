<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CHORUS: Perceptual Storyteller</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
            overflow: hidden;
        }
        #appContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .toolbar {
            flex-shrink: 0;
            position: relative;
        }
        #mainContent {
            position: relative;
            flex-grow: 1;
            overflow: hidden;
        }
        #noteCanvasContainer {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #e9e9e9;
            cursor: grab;
            touch-action: none;
        }
        #noteCanvasContainer:focus { outline: none; }
        #noteCanvasContainer.panning { cursor: grabbing; }
        #transformContainer {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
        }
        #noteCanvas {
            width: 4000px;
            height: 3000px;
            position: relative;
            background-image:
                linear-gradient(to right, #d0d0d0 1px, transparent 1px),
                linear-gradient(to bottom, #d0d0d0 1px, transparent 1px);
            background-size: 20px 20px;
            background-color: #fdfdfd;
        }
        #svgCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .chorus-chunk {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-width: 240px;
            min-height: 140px;
            display: flex;
            flex-direction: column;
            overflow: visible;
            transition: border-color 0.2s, outline 0.2s, opacity 0.3s, transform 0.3s;
            z-index: 1;
        }
        .chorus-chunk.selected-chunk { border-color: #2563eb; border-width: 2px; }
        .chorus-chunk.linking-source-chunk { outline: 2px solid #16a34a; border-color: #16a34a; }
        .chunk-header {
            padding: 6px 10px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: move;
            border-bottom: 1px solid #ccc;
            user-select: none;
            overflow: hidden;
            display: flex;
            justify-content: space-between;
            align-items: center;
            touch-action: none;
        }
        .chunk-header-title {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .chunk-header-main {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .chunk-header-main .shape-icon svg {
            width: 14px;
            height: 14px;
            stroke-width: 2;
            fill: none;
            stroke: #374151;
        }
        .chunk-color-symbol {
            font-size: 1.1em;
        }
        .chunk-functional-essence {
            font-size: 0.7rem;
            font-weight: 400;
            color: #6b7280;
        }
        .chunk-actions { display: flex; align-items: center; }
        .chunk-action-btn { background: none; border: none; cursor: pointer; padding: 2px; margin-left: 4px; line-height: 1; }
        .chunk-action-btn svg { width: 16px; height: 16px; stroke: #555; stroke-width: 2; }
        .chunk-action-btn:hover svg { stroke: #333; }
        .delete-chunk-btn:hover svg { stroke: #d00; }
        .ai-chunk-btn:hover svg { stroke: #8b5cf6; }
        .link-chunk-btn.linking-active svg { stroke: #16a34a !important; }
        .chunk-content { flex-grow: 1; padding: 12px; font-size: 0.9rem; overflow-y: auto; outline: none; }
        .resize-handle { width: 16px; height: 16px; background-color: #bbb; position: absolute; right: -4px; bottom: -4px; cursor: se-resize; border-top-left-radius: 4px; z-index: 10; touch-action: none; }
        
        .connecting-line { stroke-width: 2.5; fill: none; }
        .link-type-triggers { /* solid */ }
        .link-type-reveals { stroke-dasharray: 8, 4; }
        .link-type-echoes { stroke-dasharray: 2, 6; }
        .link-type-contrasts { stroke-dasharray: 12, 4, 4, 4; }
        .arrow-head { }
        .link-label { font-family: 'Inter', sans-serif; font-size: 14px; fill: #374151; text-anchor: middle; dominant-baseline: middle; pointer-events: none; background-color: rgba(255,255,255,0.7); padding: 2px 4px; border-radius: 4px; }

        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 10000; }
        .modal-content { background-color: white; padding: 24px; border-radius: 8px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); width: 90%; max-width: 500px; }
        .form-input, .form-textarea, .form-select { width: 100%; padding: 8px 12px; border: 1px solid #ccc; border-radius: 6px; margin-bottom: 12px; background-color: white; }
        .form-textarea { min-height: 100px; resize: vertical; }
        .btn { padding: 8px 12px; border-radius: 6px; font-weight: 500; cursor: pointer; transition: background-color 0.2s, color 0.2s, opacity 0.2s; margin-right: 8px; border: none; display: inline-flex; align-items: center; justify-content: center; white-space: nowrap; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background-color: #2563eb; color: white; }
        .btn-primary:hover:not(:disabled) { background-color: #1d4ed8; }
        .btn-secondary { background-color: #e5e7eb; color: #374151; }
        .btn-secondary:hover:not(:disabled) { background-color: #d1d5db; }
        .btn-danger { background-color: #dc2626; color: white; }
        .btn-danger:hover:not(:disabled) { background-color: #b91c1c; }
        .btn-donate { background-color: #ec4899; color: white; }
        .btn-donate:hover { background-color: #db2777; }
        #helpModal .modal-content, #messageModal .modal-content, #unlinkModal .modal-content, #linkEditModal .modal-content, #templatesModal .modal-content, #settingsModal .modal-content, #aiActionModal .modal-content { display: flex; flex-direction: column; max-height: 80vh; }
        #messageText, #help-scroll-content, #unlinkList, #templateList { max-height: 60vh; overflow-y: auto; padding-right: 1rem;}
        body.linking-mode { cursor: crosshair; }
        body.linking-mode .chorus-chunk:not(.linking-source-chunk):hover { outline: 2px dashed #2563eb; }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; line-height: 1; }
        .close-button:hover, .close-button:focus { color: black; text-decoration: none; cursor: pointer; }
        .help-section { border-bottom: 1px solid #e5e7eb; padding-bottom: 12px; margin-bottom: 12px; }
        .help-section:last-child { border-bottom: none; }
        .help-section h3 { font-size: 1.1rem; font-weight: 600; margin-bottom: 8px; }
        .help-section ul { list-style-type: disc; margin-left: 20px; }
        .help-section li { margin-bottom: 6px; }
        .help-section code { background-color: #f3f4f6; padding: 2px 4px; border-radius: 4px; font-size: 0.85em; }

        /* Dropdowns */
        .dropdown { position: relative; display: inline-block; }
        .dropdown-content { display: none; position: absolute; background-color: #f9f9f9; min-width: 160px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 100; right: 0; border-radius: 6px; padding: 4px; }
        .dropdown-content button { display: block; width: 100%; text-align: left; padding: 8px 12px; background: none; border: none; cursor: pointer; }
        .dropdown-content button:hover { background-color: #f1f1f1; }
        .dropdown-content.show { display: block; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div id="appContainer">
        <!-- Toolbar -->
        <div class="toolbar p-3 bg-white shadow-md flex flex-col sm:flex-row items-center justify-center sm:justify-between gap-3 print:hidden">
            <!-- Left Group -->
            <div class="flex items-center flex-wrap justify-center gap-2">
                <button id="addChunkBtn" class="btn btn-primary" title="Add Chunk (A)">Add</button>
                <button id="templatesBtn" class="btn btn-secondary" title="Load a narrative template">Templates</button>
                <button id="clearCanvasBtn" class="btn btn-danger" title="Clear Canvas">Clear</button>
                <button id="undoDeleteBtn" class="btn btn-secondary" title="Undo Last Delete (Ctrl/Cmd+Z)" disabled>Undo</button>
            </div>

            <!-- Center Group (Zoom) -->
            <div class="flex items-center justify-center gap-1">
                 <button id="zoomOutBtn" class="btn btn-secondary !p-2" title="Zoom Out (-)">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M20 12H4" /></svg>
                 </button>
                 <button id="zoomResetBtn" class="btn btn-secondary" title="Reset Zoom (100%)">100%</button>
                 <button id="zoomInBtn" class="btn btn-secondary !p-2" title="Zoom In (+)">
                     <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v12m6-6H6" /></svg>
                 </button>
            </div>

            <!-- Right Group -->
            <div class="flex items-center flex-wrap justify-center gap-2">
                <span id="chunkCountDisplay" class="text-sm text-gray-500 mx-2">Chunks: 0</span>
                 <div class="dropdown">
                    <button id="exportBtn" class="btn btn-secondary">Export</button>
                    <div id="exportDropdownContent" class="dropdown-content">
                        <button id="exportTxtBtn">Simple TXT</button>
                        <button id="exportNarrativeTxtBtn">Narrative TXT</button>
                        <button id="exportJsonBtn">JSON</button>
                        <hr class="my-1">
                        <button id="exportYarnBtn">Yarn Spinner (.yarn)</button>
                        <button id="exportTweeBtn">Twee (.twee)</button>
                        <button id="exportInkBtn">Ink (.ink)</button>
                        <button id="exportRenpyBtn">Ren'Py (.rpy)</button>
                        <button id="exportI7Btn">Inform 7 (.ni)</button>
                         <hr class="my-1">
                        <button id="exportArticyBtn">articy:draft</button>
                    </div>
                </div>
                <button id="saveBtn" class="btn btn-secondary" title="Save to File (Ctrl/Cmd+S)">Save</button>
                <button id="loadBtn" class="btn btn-secondary" title="Load from File (Ctrl/Cmd+O)">Load</button>
                <button id="settingsBtn" class="btn btn-secondary" title="Settings">Settings</button>
                <button id="helpBtn" class="btn btn-secondary" title="Help (?)">Help</button>
            </div>
        </div>

        <!-- Main Content Area -->
        <div id="mainContent">
            <div id="noteCanvasContainer" tabindex="-1">
                <div id="transformContainer">
                    <div id="noteCanvas">
                        <svg id="svgCanvas"></svg>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="text-center p-2 text-xs text-gray-500 print:hidden">
        &copy; <span id="copyrightYear"></span> Thorsten Becker. CHORUS: Perceptual Storyteller.
    </footer>

    <!-- Modals -->
    <div id="addChunkModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2>Add New Chunk</h2>
            <label for="chunkTypeSelect" class="block mb-1 font-medium">Chunk Type:</label>
            <select id="chunkTypeSelect" class="form-select"></select>
            <label for="addChunkShapeSelect" class="block mb-1 mt-3 font-medium">Functional Shape:</label>
            <select id="addChunkShapeSelect" class="form-select"></select>
            <label for="addChunkColorSelect" class="block mb-1 mt-3 font-medium">Emotional Color:</label>
            <select id="addChunkColorSelect" class="form-select"></select>
            <div class="mt-6 flex justify-end">
                <button id="cancelAddChunkBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmAddChunkBtn" class="btn btn-primary">Add</button>
            </div>
        </div>
    </div>
    <div id="editChunkModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2>Edit Chunk</h2>
            <input type="hidden" id="editingChunkId">
            <label for="editChunkTypeSelect" class="block mb-1 font-medium">Chunk Type:</label>
            <select id="editChunkTypeSelect" class="form-select"></select>
            <label for="editChunkShapeSelect" class="block mb-1 mt-3 font-medium">Functional Shape:</label>
            <select id="editChunkShapeSelect" class="form-select"></select>
            <label for="editChunkColorSelect" class="block mb-1 mt-3 font-medium">Emotional Color:</label>
            <select id="editChunkColorSelect" class="form-select"></select>
            <div id="editModalActions" class="mt-6 flex justify-end">
                <button id="cancelEditChunkBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmEditChunkBtn" class="btn btn-primary">Save Changes</button>
            </div>
        </div>
    </div>
    <div id="linkEditModal" class="modal hidden">
        <div class="modal-content">
            <h2 id="linkEditTitle">Create Relationship</h2>
            <input type="hidden" id="linkSourceId">
            <input type="hidden" id="linkTargetId">
            <label for="linkTypeSelect" class="block mb-1 font-medium">Relationship Type:</label>
            <select id="linkTypeSelect" class="form-select"></select>
            <label for="linkLabelInput" class="block mb-1 mt-3 font-medium">Relationship Note (optional):</label>
            <input type="text" id="linkLabelInput" class="form-input" placeholder="(e.g., The smell reminds her of home)">
            <div class="mt-6 flex justify-end">
                <button id="cancelLinkEditBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmLinkEditBtn" class="btn btn-primary">Create Link</button>
            </div>
        </div>
    </div>
     <div id="templatesModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2>Load a Narrative Template</h2>
            <p class="text-sm text-gray-600 mb-4">Choose a built-in template or load your own.</p>
            <div id="templateList" class="space-y-2 mb-4 border-b pb-4"></div>
             <div class="flex flex-col space-y-2">
                <button id="saveCanvasAsTemplateBtn" class="btn btn-secondary w-full">Save Canvas as Template</button>
                <button id="loadCustomTemplateBtn" class="btn btn-secondary w-full">Load Custom Template...</button>
             </div>
        </div>
    </div>
    <div id="settingsModal" class="modal hidden">
        <div class="modal-content">
            <span id="closeSettingsModalBtn" class="close-button">&times;</span>
            <h2>Settings</h2>
            <div class="mt-4">
                <h3 class="font-semibold text-lg mb-2">API Key</h3>
                <p class="text-xs text-gray-500 mb-2">Required for AI features. Your key is saved only in this browser's local storage.</p>
                <input type="password" id="geminiApiKeyInput" class="form-input" placeholder="Enter your Google AI API key here">
                <p class="text-xs text-gray-500 mb-4">Get a key from <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-blue-600 hover:underline">Google AI Studio</a>.</p>
            </div>
             <div class="mt-6 flex justify-end">
                <button id="saveSettingsBtn" class="btn btn-primary">Save & Close</button>
            </div>
        </div>
    </div>
     <div id="aiActionModal" class="modal hidden">
        <div class="modal-content">
             <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2 class="flex items-center"><span class="mr-2">✨</span>AI Assistant</h2>
            <p class="text-sm text-gray-600 mb-4">Use AI to expand and explore your narrative ideas. Current chunk content will be used as context.</p>
            <div class="space-y-2">
                <button id="aiActionDeepenBtn" class="btn btn-secondary w-full justify-start">✨ Deepen Sensory Details</button>
                <button id="aiActionInternalStateBtn" class="btn btn-secondary w-full justify-start">✨ Explore Internal State</button>
                <button id="aiActionSuggestEchoBtn" class="btn btn-secondary w-full justify-start">✨ Suggest an "Echo"</button>
            </div>
        </div>
    </div>
    <div id="unlinkModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2>Manage Relationships</h2>
            <p class="text-sm text-gray-600 mb-4">Remove or edit outgoing relationships from this chunk.</p>
            <div id="unlinkList" class="space-y-2"></div>
            <div class="mt-6 flex justify-end">
                <button id="closeUnlinkModalBtn" class="btn btn-primary">Done</button>
            </div>
        </div>
    </div>
    <div id="helpModal" class="modal hidden">
        <div class="modal-content">
            <span id="closeHelpModalSpan" class="close-button">&times;</span>
            <h2>CHORUS Quick Help</h2>
            <div id="help-scroll-content">
                 <div class="help-section">
                    <h3>What is CHORUS Perceptual Storyteller?</h3>
                    <p class="mb-2">This is a tool for mapping stories from an emotional and perceptual perspective. Instead of focusing on plot points, it helps you structure a narrative based on environmental cues, internal feelings, and shifts in a character's perception.</p>
                    <p>The goal is to visually choreograph the "inner" story—the one of feeling and experience—that drives the external plot.</p>
                </div>
                 <div class="help-section">
                    <h3>Usage & Licensing</h3>
                    <p class="mb-3 text-sm">
                        CHORUS is free for personal, non-commercial, and educational use. If you are a solo or small indie developer, you are also welcome to use this tool, and a donation would be greatly appreciated.
                    </p>
                    <div class="my-4 flex justify-center">
                        <a href="https://ko-fi.com/thorstenbecker" target="_blank" rel="noopener noreferrer" class="inline-flex items-center justify-center px-4 py-2 border border-transparent text-base font-medium rounded-md text-white bg-pink-500 hover:bg-pink-600 shadow-sm">
                           <span class="mr-2 font-bold text-lg">$</span> Donate via Ko-fi
                        </a>
                    </div>
                    <p class="text-sm">
                        For all other commercial uses, please contact me to arrange for a license: <a href="mailto:hello@thorstenbecker.de" class="text-blue-600 hover:underline">hello@thorstenbecker.de</a>.
                    </p>
                </div>
                <div class="help-section">
                    <h3>✨ The Core Method</h3>
                    <p>CHORUS is built on three layers of visual grammar:</p>
                    <ul>
                        <li><strong>Chunks (The "What"):</strong> Self-contained moments of perception, feeling, or thought.</li>
                        <li><strong>Shapes (The "How"):</strong> Defines a chunk's function (Internal, External, Shift, etc.).</li>
                        <li><strong>Colors (The "Feeling"):</strong> Represents the emotional tone (Conflict, Calm, etc.).</li>
                        <li><strong>Relationships (The "Why"):</strong> Lines show how chunks influence each other (*triggers*, *reveals*, etc.).</li>
                         <li><strong>AI Assistant (The "Spark"):</strong> Use the ✨ icon in any chunk to deepen details, explore internal states, or suggest thematic echoes. Requires a Google AI API key.</li>
                    </ul>
                </div>
                 <div class="help-section">
                    <h3>Custom Templates</h3>
                    <p>You can save your own canvas layouts as templates. In the "Templates" modal, click "Save Canvas as Template" to download a <code>.chtml</code> file. Use "Load Custom Template" to open a template file you've saved.</p>
                </div>
                <div class="help-section"><h3>Functional Shapes</h3><ul id="helpShapes"></ul></div>
                <div class="help-section"><h3>Emotional Colors</h3><ul id="helpColors"></ul></div>
                <div class="help-section"><h3>Relationship Types</h3><ul id="helpLinkTypes"></ul></div>
                <div class="help-section"><h3>Chunk Types</h3><ul id="helpCoreChunks"></ul></div>
            </div>
            <div class="mt-6 flex justify-end"><button id="closeHelpBtn" class="btn btn-primary">OK</button></div>
        </div>
    </div>
    <div id="messageModal" class="modal hidden">
        <div class="modal-content max-w-lg">
            <h2 id="messageTitle" class="text-xl font-semibold mb-3">Message</h2>
            <div id="messageText" class="mb-4 text-sm"></div>
            <div id="messageButtons" class="flex justify-end"></div>
        </div>
    </div>
    <input type="file" id="fileLoadInput" class="hidden" accept=".json,application/json">
    <input type="file" id="templateLoadInput" class="hidden" accept=".chtml,application/json">


    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Constants & Definitions ---
        const DEFAULT_CHUNK_TYPES = {
            perception: [ { tag: "#Sensory-Cue", description: "Something a character sees, hears, smells, etc." }, { tag: "#Environmental-Detail", description: "A feature of the setting or atmosphere." }, { tag: "#Object-Focus", description: "A specific, meaningful object." } ],
            emotion: [ { tag: "#Emotional-Beat", description: "A clear expression of a feeling." }, { tag: "#Internal-Feeling", description: "A character's private, inner emotion." }, { tag: "#Mood-Shift", description: "A change in the emotional atmosphere." } ],
            cognition: [ { tag: "#Character-Insight", description: "A realization or dawning awareness." }, { tag: "#Memory", description: "A flashback or recollection." }, { tag: "#Internal-Monologue", description: "A character's direct thoughts." } ],
            action: [ { tag: "#Decision-Point", description: "A moment where a character must choose." }, { tag: "#Character-Action", description: "A physical action taken by a character." }, { tag: "#Consequence", description: "The result of a previous action or event." } ]
        };
        const SHAPES = [
            { name: "Circle",   symbol: "◯", essence: "Internal Feeling/Thought", svg: `<circle cx="7" cy="7" r="6" />`},
            { name: "Square",   symbol: "□", essence: "External Cue/Observation", svg: `<rect x="1" y="1" width="12" height="12" />`},
            { name: "Triangle", symbol: "△", essence: "Shift/Change in Perception", svg: `<path d="M7 1 L13 13 L1 13 Z" />`},
            { name: "Diamond",  symbol: "◇", essence: "Core Insight/Realization", svg: `<path d="M7 1 L13 7 L7 13 L1 7 Z" />`},
            { name: "Arrow",    symbol: "→", essence: "Action/Decision", svg: `<path d="M1 7 L11 7 M8 4 L11 7 L8 10" />`}
        ];
        const COLORS = [ 
            { name: "White",   symbol: "⚪", essence: "Open, Uncategorized", hex: "#f8fafc" },
            { name: "Red",     symbol: "🔴", essence: "Conflict, Danger, Tension", hex: "#fecaca" }, 
            { name: "Blue",    symbol: "🔵", essence: "Reflection, Sadness, Calm", hex: "#bfdbfe" }, 
            { name: "Green",   symbol: "🟢", essence: "Growth, Positive Outcome", hex: "#bbf7d0" }, 
            { name: "Yellow",  symbol: "🟡", essence: "Discovery, Hope, Key Insight", hex: "#fef08a" }, 
            { name: "Purple",  symbol: "🟣", essence: "Mystery, Intrigue, the Subconscious", hex: "#e9d5ff" }, 
            { name: "Grey",    symbol: "🩶", essence: "Exposition, Neutral Observation", hex: "#e5e7eb" },
            { name: "Black",   symbol: "⚫", essence: "Finality, Consequence, Trauma", hex: "#d1d5db" }
        ];
        const LINK_TYPES = [
            { type: "triggers", label: "Triggers (Cause & Effect)", style: "solid" },
            { type: "reveals", label: "Reveals (Uncovers Information)", style: "dashed" },
            { type: "echoes", label: "Echoes (Thematic/Symbolic Link)", style: "dotted" },
            { type: "contrasts", label: "Contrasts (Opposition/Duality)", style: "complex-dash" }
        ];
        const NARRATIVE_TEMPLATES = {
            thresholdMoment: {
                name: "The Threshold Moment",
                description: "A character's perception before and after a key event.",
                chunks: [ 
                    {id: "a1", x:100, y:250, w:250, h:150, type: "#Environmental-Detail", shape: "Square", color: "Grey", text: "Before: The room is just a room. Clinical and quiet."}, 
                    {id: "a2", x:450, y:250, w:250, h:150, type: "#Sensory-Cue", shape: "Triangle", color: "Red", text: "The Trigger: A discordant chime echoes from a hidden speaker."}, 
                    {id: "a3", x:800, y:150, w:250, h:150, type: "#Mood-Shift", shape: "Circle", color: "Blue", text: "After: The quiet is no longer calm, but menacing. Every shadow seems to lengthen."},
                    {id: "a4", x:800, y:350, w:250, h:150, type: "#Character-Insight", shape: "Diamond", color: "Yellow", text: "Realization: 'This isn't a hospital. It's a prison.'"}
                ],
                links: [ 
                    { from: "a1", to: "a2", type: "triggers" }, 
                    { from: "a2", to: "a3", type: "triggers", label: "causes" },
                    { from: "a2", to: "a4", type: "reveals", label: "leads to" }
                ]
            },
            hauntedMemory: {
                name: "The Haunted Memory",
                description: "An external cue triggers a memory, coloring present perception.",
                chunks: [ 
                    {id: "h1", x:100, y:200, w:250, h:150, type: "#Object-Focus", shape: "Square", color: "Grey", text: "A cracked porcelain doll sits on the shelf."}, 
                    {id: "h2", x:450, y:200, w:250, h:150, type: "#Memory", shape: "Circle", color: "Purple", text: "Flashback: A memory of a childhood friend, lost long ago, who owned a similar doll."}, 
                    {id: "h3", x:800, y:200, w:250, h:150, type: "#Internal-Feeling", shape: "Circle", color: "Blue", text: "A wave of unexpected sadness and longing washes over the character."} 
                ],
                links: [ 
                    { from: "h1", to: "h2", type: "triggers", label: "triggers"}, 
                    { from: "h2", to: "h3", type: "echoes", label: "colors the present"}
                ]
            }
        };
        const ICON_PENCIL_EDIT = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" /></svg>`;
        const ICON_LINK = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" /></svg>`;
        const ICON_LINKING_ACTIVE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="animate-pulse"><path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" /></svg>`;
        const ICON_DELETE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" /></svg>`;
        const ICON_AI_SPARKLE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.25 10.5l-1.5-1.5 1.5-1.5 1.5 1.5-1.5 1.5ZM16.5 3.75l-1.5-1.5 1.5-1.5 1.5 1.5-1.5 1.5Z" /></svg>`;

        // --- DOM Elements Cache ---
        const noteCanvasContainer = document.getElementById('noteCanvasContainer'); const mainContent = document.getElementById('mainContent'); const transformContainer = document.getElementById('transformContainer'); const svgCanvas = document.getElementById('svgCanvas'); const noteCanvas = document.getElementById('noteCanvas'); const addChunkBtn = document.getElementById('addChunkBtn'); const templatesBtn = document.getElementById('templatesBtn'); const templatesModal = document.getElementById('templatesModal'); const templateList = document.getElementById('templateList'); const clearCanvasBtn = document.getElementById('clearCanvasBtn'); const undoDeleteBtn = document.getElementById('undoDeleteBtn'); const chunkCountDisplay = document.getElementById('chunkCountDisplay'); const addChunkModal = document.getElementById('addChunkModal'); const chunkTypeSelect = document.getElementById('chunkTypeSelect'); const addChunkShapeSelect = document.getElementById('addChunkShapeSelect'); const addChunkColorSelect = document.getElementById('addChunkColorSelect'); const confirmAddChunkBtn = document.getElementById('confirmAddChunkBtn'); const cancelAddChunkBtn = document.getElementById('cancelAddChunkBtn'); const editChunkModal = document.getElementById('editChunkModal'); const editingChunkIdInput = document.getElementById('editingChunkId'); const editChunkTypeSelect = document.getElementById('editChunkTypeSelect'); const editChunkShapeSelect = document.getElementById('editChunkShapeSelect'); const editChunkColorSelect = document.getElementById('editChunkColorSelect'); const confirmEditChunkBtn = document.getElementById('confirmEditChunkBtn'); const cancelEditChunkBtn = document.getElementById('cancelEditChunkBtn'); const helpBtn = document.getElementById('helpBtn'); const helpModal = document.getElementById('helpModal'); const closeHelpBtn = document.getElementById('closeHelpBtn'); const closeHelpModalSpan = document.getElementById('closeHelpModalSpan'); const saveBtn = document.getElementById('saveBtn'); const loadBtn = document.getElementById('loadBtn'); const fileLoadInput = document.getElementById('fileLoadInput'); const messageModal = document.getElementById('messageModal'); const messageTitle = document.getElementById('messageTitle'); const messageText = document.getElementById('messageText'); const messageButtons = document.getElementById('messageButtons');
        const unlinkModal = document.getElementById('unlinkModal'); const unlinkList = document.getElementById('unlinkList'); const closeUnlinkModalBtn = document.getElementById('closeUnlinkModalBtn');
        const exportJsonBtn = document.getElementById('exportJsonBtn'); const exportYarnBtn = document.getElementById('exportYarnBtn'); const exportTweeBtn = document.getElementById('exportTweeBtn'); const exportTxtBtn = document.getElementById('exportTxtBtn');
        const exportNarrativeTxtBtn = document.getElementById('exportNarrativeTxtBtn');
        const exportInkBtn = document.getElementById('exportInkBtn');
        const exportRenpyBtn = document.getElementById('exportRenpyBtn');
        const exportI7Btn = document.getElementById('exportI7Btn');
        const exportArticyBtn = document.getElementById('exportArticyBtn');
        const linkEditModal = document.getElementById('linkEditModal'); const linkEditTitle = document.getElementById('linkEditTitle'); const linkTypeSelect = document.getElementById('linkTypeSelect'); const linkLabelInput = document.getElementById('linkLabelInput'); const cancelLinkEditBtn = document.getElementById('cancelLinkEditBtn'); const confirmLinkEditBtn = document.getElementById('confirmLinkEditBtn'); const linkSourceIdInput = document.getElementById('linkSourceId'); const linkTargetIdInput = document.getElementById('linkTargetId');
        const saveCanvasAsTemplateBtn = document.getElementById('saveCanvasAsTemplateBtn'); const loadCustomTemplateBtn = document.getElementById('loadCustomTemplateBtn'); const templateLoadInput = document.getElementById('templateLoadInput');
        const settingsBtn = document.getElementById('settingsBtn'); const settingsModal = document.getElementById('settingsModal'); const closeSettingsModalBtn = document.getElementById('closeSettingsModalBtn'); const saveSettingsBtn = document.getElementById('saveSettingsBtn'); const geminiApiKeyInput = document.getElementById('geminiApiKeyInput');
        const aiActionModal = document.getElementById('aiActionModal'); const aiActionDeepenBtn = document.getElementById('aiActionDeepenBtn'); const aiActionInternalStateBtn = document.getElementById('aiActionInternalStateBtn'); const aiActionSuggestEchoBtn = document.getElementById('aiActionSuggestEchoBtn');
        const zoomInBtn = document.getElementById('zoomInBtn'); const zoomOutBtn = document.getElementById('zoomOutBtn'); const zoomResetBtn = document.getElementById('zoomResetBtn');

        // --- App State ---
        let chunkTypes = {}; let allChunkTypesList = []; let chunks = []; let chunksMap = new Map();
        let highestZIndex = 1; let draggedChunk = null; let resizingChunk = null; let interactionStartX = 0; let interactionStartY = 0; let offsetX = 0; let offsetY = 0; let startX = 0; let startY = 0; let startWidth = 0; let startHeight = 0; let selectedChunkId = null; let linkingMode = false; let linkingSourceChunkId = null; let lastDeletedChunk = null;
        let scale = 1; let translateX = 0; let translateY = 0; const MIN_SCALE = 0.1; const MAX_SCALE = 3.0; const ZOOM_SENSITIVITY = 0.001;
        let currentAction = null; let panStartX = 0; let panStartY = 0; let initialPinchDistance = null; let transformUpdateQueued = false;
        let geminiApiKey = null; let activeAiChunkId = null;

        // --- Utility & Setup Functions ---
        function generateId() { return 'chunk_' + Date.now() + '-' + Math.random().toString(36).substring(2, 9); }
        function showModal(modalElement) { modalElement.classList.remove('hidden'); }
        function hideModal(modalElement) { modalElement.classList.add('hidden'); }
        function showMessage(title, text, buttonsConfig = [{ text: 'OK', class: 'btn-primary', action: () => hideModal(messageModal) }]) {
            messageTitle.textContent = title; messageText.innerHTML = text; messageButtons.innerHTML = '';
            buttonsConfig.forEach(btnConfig => {
                const button = document.createElement('button');
                button.className = `btn ${btnConfig.class || 'btn-secondary'}`; button.textContent = btnConfig.text;
                button.onclick = () => { if (btnConfig.action) btnConfig.action(); if (!btnConfig.noHide) hideModal(messageModal); };
                messageButtons.appendChild(button);
            });
            showModal(messageModal);
        }
        function updateChunkCounter() { chunkCountDisplay.textContent = `Chunks: ${chunks.length}`; }

        function populateSelectWithOptions(selectElement, optionsArray, currentValue, groups = null, groupLabelFormatterFn = null) {
            selectElement.innerHTML = '';
            if (groups && groupLabelFormatterFn) {
                 for (const groupKey in groups) {
                    if (groups.hasOwnProperty(groupKey) && groups[groupKey].length > 0) {
                        const groupItems = groups[groupKey];
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = groupLabelFormatterFn(groupKey);
                        groupItems.forEach(item => {
                            const option = document.createElement('option');
                            option.value = item.tag; option.textContent = `${item.tag} - ${item.description}`;
                            if (item.tag === currentValue) option.selected = true;
                            optgroup.appendChild(option);
                        });
                        selectElement.appendChild(optgroup);
                    }
                }
            } else if (optionsArray) {
                optionsArray.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt.value; option.textContent = opt.text;
                    if (opt.value === currentValue) option.selected = true;
                    selectElement.appendChild(option);
                });
            }
        }

        function populateHelpModal() {
            allChunkTypesList = Object.values(chunkTypes).flat();
            document.getElementById('helpShapes').innerHTML = SHAPES.map(s => `<li><span class="font-bold">${s.symbol} ${s.name}</span>: ${s.essence}</li>`).join('');
            document.getElementById('helpColors').innerHTML = COLORS.map(c => `<li><span class="font-bold">${c.symbol} ${c.name}</span>: ${c.essence}</li>`).join('');
            document.getElementById('helpLinkTypes').innerHTML = LINK_TYPES.map(l => `<li><span class="font-bold">${l.label}</span>: Use for showing how chunks influence each other.</li>`).join('');
            document.getElementById('helpCoreChunks').innerHTML = allChunkTypesList.map(c => `<li><code>${c.tag}</code>: ${c.description}</li>`).join('');
        }

        function populateAddChunkModal() { 
            populateSelectWithOptions(chunkTypeSelect, null, null, chunkTypes, key => key.charAt(0).toUpperCase() + key.slice(1) + " Types"); 
            populateSelectWithOptions(addChunkShapeSelect, SHAPES.map(shape => ({value: shape.name, text: `${shape.symbol} ${shape.name} - ${shape.essence}`})), "Square");
            populateSelectWithOptions(addChunkColorSelect, COLORS.map(c => ({value: c.name, text: `${c.symbol} ${c.name} - ${c.essence}`})), "White");
        }
        
        // --- Custom Chunk Type Management ---
        function loadCustomChunkTypes() {
            // Simplified for this version - always uses default
            chunkTypes = JSON.parse(JSON.stringify(DEFAULT_CHUNK_TYPES)); 
            allChunkTypesList = Object.values(chunkTypes).flat();
            populateHelpModal();
        }
       
        // --- Template Management ---
        function setupTemplateModal() {
            templateList.innerHTML = '';
            for (const key in NARRATIVE_TEMPLATES) {
                const template = NARRATIVE_TEMPLATES[key];
                const btn = document.createElement('button');
                btn.className = 'btn btn-secondary w-full text-left justify-start';
                btn.innerHTML = `<div><div class="font-bold">${template.name}</div><div class="text-sm font-normal">${template.description}</div></div>`;
                btn.onclick = () => {
                    showMessage("Confirm Load Template", `This will clear the current canvas. Are you sure you want to load the "${template.name}" template?`, [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Load Template', class: 'btn-primary', action: () => { loadTemplate(template); hideModal(templatesModal); } } ]);
                };
                templateList.appendChild(btn);
            }
        }
        function loadTemplate(template) {
            if (!template || !template.chunks) return;

            renderBoard([]); // Clear the board first

            const loadedChunksData = [];
            const idMap = new Map();

            let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
            template.chunks.forEach(chunkTmpl => {
                minX = Math.min(minX, chunkTmpl.x);
                minY = Math.min(minY, chunkTmpl.y);
                maxX = Math.max(maxX, chunkTmpl.x + chunkTmpl.w);
                maxY = Math.max(maxY, chunkTmpl.y + chunkTmpl.h);
            });
            const templateWidth = maxX - minX;
            const templateHeight = maxY - minY;

            const viewportRect = noteCanvasContainer.getBoundingClientRect();
            const viewportCenterX = (viewportRect.width / 2);
            const viewportCenterY = (viewportRect.height / 2);
            const worldCenter = screenToWorld(viewportCenterX, viewportCenterY);

            const offsetX = worldCenter.x - (minX + templateWidth / 2);
            const offsetY = worldCenter.y - (minY + templateHeight / 2);

            template.chunks.forEach(chunkTmpl => {
                const chunkType = allChunkTypesList.find(ct => ct.tag === chunkTmpl.type);
                if(!chunkType) { console.warn("Skipping template chunk with invalid type:", chunkTmpl); return; }
                const newId = generateId();
                if(chunkTmpl.id) idMap.set(chunkTmpl.id, newId);
                
                const newChunkData = {
                    id: newId,
                    chunkTypeTag: chunkTmpl.type,
                    shape: chunkTmpl.shape || "Square",
                    color: chunkTmpl.color || "White",
                    text: chunkTmpl.text || '...',
                    x: (chunkTmpl.x || 0) + offsetX,
                    y: (chunkTmpl.y || 0) + offsetY,
                    width: chunkTmpl.w || 250, height: chunkTmpl.h || 140,
                    zIndex: ++highestZIndex,
                    links: [] 
                };
                loadedChunksData.push(newChunkData);
            });

            if (template.links) {
                template.links.forEach(link => {
                    const sourceId = idMap.get(link.from); const targetId = idMap.get(link.to);
                    const sourceChunk = loadedChunksData.find(c => c.id === sourceId);
                    if(sourceChunk && targetId) { sourceChunk.links.push({ targetId, label: link.label || '', type: link.type || 'triggers' }); }
                });
            }
            
            renderBoard(loadedChunksData);
        }

        // --- Transform and Coordinate Functions ---
        function applyTransform() { if (!transformUpdateQueued) { transformUpdateQueued = true; requestAnimationFrame(() => { transformContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`; svgCanvas.setAttribute('width', String(noteCanvas.scrollWidth)); svgCanvas.setAttribute('height', String(noteCanvas.scrollHeight)); drawConnections(); transformUpdateQueued = false; }); } }
        function zoomAtPoint(newScale, pointX, pointY) {
            newScale = Math.max(MIN_SCALE, Math.min(newScale, MAX_SCALE));
            const worldXBeforeZoom = (pointX - translateX) / scale;
            const worldYBeforeZoom = (pointY - translateY) / scale;
            translateX = pointX - worldXBeforeZoom * newScale;
            translateY = pointY - worldYBeforeZoom * newScale;
            scale = newScale;
            applyTransform();
        }
        function resetAndCenterView() { scale = 1; const viewportWidth = noteCanvasContainer.clientWidth; const viewportHeight = noteCanvasContainer.clientHeight; const canvasContentWidth = noteCanvas.scrollWidth; const canvasContentHeight = noteCanvas.scrollHeight; translateX = (viewportWidth - canvasContentWidth * scale) / 2; translateY = (viewportHeight - canvasContentHeight * scale) / 2; applyTransform(); }
        function screenToWorld(screenX, screenY) { const containerRect = noteCanvasContainer.getBoundingClientRect(); const rectLeft = containerRect.left || 0; const rectTop = containerRect.top || 0; const worldX = (screenX - rectLeft - translateX) / scale; const worldY = (screenY - rectTop - translateY) / scale; return { x: worldX, y: worldY }; }
        function getPointerCoordinates(e) { if (e.touches && e.touches.length > 0) { return { x: e.touches[0].clientX, y: e.touches[0].clientY, count: e.touches.length }; } return { x: e.clientX, y: e.clientY, count: e.buttons === 1 ? 1 : 0 }; }
        
        // --- Gemini AI Functions ---
        function loadApiKey() { const key = localStorage.getItem('geminiApiKey'); if (key) { geminiApiKey = key; geminiApiKeyInput.value = key; } }
        function saveApiKey() { const key = geminiApiKeyInput.value.trim(); if (key) { geminiApiKey = key; localStorage.setItem('geminiApiKey', key); showMessage("API Key Saved", "Your Gemini API key has been saved locally."); } else { localStorage.removeItem('geminiApiKey'); geminiApiKey = null; showMessage("API Key Cleared", "Your API key has been removed."); } }
        
        const originalButtonStates = {};
        function setButtonLoading(button, isLoading) { if (!button) { return; } const buttonId = button.id || `btn-${Math.random()}`; button.id = buttonId; if (isLoading) { if (!originalButtonStates[buttonId]) { originalButtonStates[buttonId] = button.innerHTML; } button.innerHTML = `<svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`; button.disabled = true; } else { if (originalButtonStates[buttonId] !== undefined) { button.innerHTML = originalButtonStates[buttonId]; delete originalButtonStates[buttonId]; } button.disabled = false; } }
        
        async function callGemini(prompt, buttonToLoad) { 
            if (!geminiApiKey) { 
                showMessage("API Key Required", "Please enter your Google AI API key in the Settings modal first.", [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Open Settings', class: 'btn-primary', action: () => showModal(settingsModal) } ]); 
                return null; 
            } 
            if (buttonToLoad) setButtonLoading(buttonToLoad, true); 
            
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${geminiApiKey}`; 
            
            try { 
                const response = await fetch(API_URL, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                }); 
                
                if (!response.ok) { 
                    const errorData = await response.json(); 
                    throw new Error(errorData.error?.message || `HTTP error! status: ${response.status}`); 
                } 
                
                const data = await response.json(); 
                
                if (data.candidates && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0) { 
                    return data.candidates[0].content.parts[0].text; 
                } else { 
                    if(data.candidates && data.candidates[0].finishReason === 'SAFETY') { 
                        throw new Error("The response was blocked due to safety settings. Please adjust your prompt."); 
                    } 
                    throw new Error("Received an empty or invalid response from the AI."); 
                } 
            } catch (error) { 
                showMessage("AI Error", `An error occurred: ${error.message}`); 
                console.error("Gemini API call failed:", error); 
                return null; 
            } finally { 
                if (buttonToLoad) setButtonLoading(buttonToLoad, false); 
            } 
        }

        function openAiModal(chunkId) { 
            if (!geminiApiKey) { 
                showMessage("API Key Required", "Please enter your Google AI API key in the Settings modal first.", [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Open Settings', class: 'btn-primary', action: () => { hideModal(aiActionModal); showModal(settingsModal); } } ]); 
                return; 
            } 
            activeAiChunkId = chunkId; 
            showModal(aiActionModal); 
        }

        async function handleDeepenSensoryDetails() {
            const chunkData = chunksMap.get(activeAiChunkId);
            if (!chunkData) { return; }
            const contentDiv = document.getElementById(activeAiChunkId)?.querySelector('.chunk-content');
            if(!contentDiv) return;
            const prompt = `Given the following narrative beat, expand on it with richer sensory details (sight, sound, smell, touch, internal bodily feelings). Respond only with the new, enhanced text, not with conversational phrases. CONTEXT: "${contentDiv.innerText}"`;
            const result = await callGemini(prompt, aiActionDeepenBtn);
            if (result) {
                let htmlResult = result.replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>'); 
                htmlResult = `<p>${htmlResult}</p>`;
                contentDiv.innerHTML = htmlResult; 
                chunkData.text = htmlResult; 
                hideModal(aiActionModal);
                showMessage("Chunk Deepened", "The chunk's content has been enhanced with sensory details.");
            }
        }
        
        async function handleExploreInternalState() {
            const sourceChunkData = chunksMap.get(activeAiChunkId);
            if (!sourceChunkData) { return; }
            const contentDiv = document.getElementById(activeAiChunkId)?.querySelector('.chunk-content');
            if(!contentDiv) return;
            const prompt = `An external event or observation is described as: "${contentDiv.innerText}". Suggest a plausible internal thought or feeling for a character experiencing this. Respond with only the text for the new thought or feeling.`;
            const newText = await callGemini(prompt, aiActionInternalStateBtn);
            if (newText) {
                const newChunkDetails = {
                    type: allChunkTypesList.find(ct => ct.tag === "#Internal-Feeling") || allChunkTypesList[0],
                    shape: "Circle",
                    color: "Purple"
                };
                const newChunkOptions = {
                    text: `<p>${newText.replace(/\n/g, '<br>')}</p>`,
                    x: sourceChunkData.x + sourceChunkData.width + 40,
                    y: sourceChunkData.y
                };
                const newChunkData = addChunkToCanvas(newChunkDetails, newChunkOptions);
                addOrUpdateLink(sourceChunkData.id, newChunkData.id, "reveals", "reveals");
                hideModal(aiActionModal);
                showMessage("Internal State Explored", "A new chunk has been created and linked to represent the character's internal state.");
            }
        }
        
        async function handleSuggestEcho() {
            const sourceChunkData = chunksMap.get(activeAiChunkId);
            if (!sourceChunkData) { return; }
            const contentDiv = document.getElementById(activeAiChunkId)?.querySelector('.chunk-content');
            if(!contentDiv) return;
            const prompt = `The following is a moment in a story: "${contentDiv.innerText}". Suggest a different, separate moment that thematically or emotionally *echoes* this one. It could be a memory, a symbol, or a future event that rhymes with this one. Respond with only the text for the new moment.`;
            const newText = await callGemini(prompt, aiActionSuggestEchoBtn);
             if (newText) {
                const newChunkDetails = {
                    type: allChunkTypesList.find(ct => ct.tag === "#Memory") || allChunkTypesList[0],
                    shape: "Square",
                    color: sourceChunkData.color
                };
                const newChunkOptions = {
                    text: `<p>${newText.replace(/\n/g, '<br>')}</p>`,
                    x: sourceChunkData.x,
                    y: sourceChunkData.y + sourceChunkData.height + 40
                };
                const newChunkData = addChunkToCanvas(newChunkDetails, newChunkOptions);
                addOrUpdateLink(sourceChunkData.id, newChunkData.id, "echoes", "echoes");
                hideModal(aiActionModal);
                showMessage("Echo Suggested", "A new chunk has been created with a thematically linked 'echo' moment.");
            }
        }


        // --- Chunk Management & Selection ---
        function updateChunkHeaderDisplay(chunkId) {
            const chunkElement = document.getElementById(chunkId);
            const chunkData = chunksMap.get(chunkId);
            if (!chunkElement || !chunkData) return;
            const header = chunkElement.querySelector('.chunk-header');
            const colorInfo = COLORS.find(c => c.name === chunkData.color) || COLORS[0];
            const shapeInfo = SHAPES.find(s => s.name === chunkData.shape) || SHAPES[0];

            header.style.backgroundColor = colorInfo.hex;
            const titleSpan = header.querySelector('.chunk-header-title');
            if (titleSpan) {
                titleSpan.innerHTML = `
                    <div class="chunk-header-main">
                        <span class="chunk-color-symbol" title="${colorInfo.name}: ${colorInfo.essence}">${colorInfo.symbol}</span>
                        <span class="shape-icon" title="${shapeInfo.name}: ${shapeInfo.essence}"><svg viewBox="0 0 14 14">${shapeInfo.svg}</svg></span>
                        <span>${chunkData.chunkTypeTag}</span>
                    </div>
                    <div class="chunk-functional-essence">${shapeInfo.essence}</div>
                `;
            }
        }
        function updateSelectedVisuals() { document.querySelectorAll('.chorus-chunk').forEach(el => { const chunkData = chunksMap.get(el.id); if (!chunkData) return; const isSelected = el.id === selectedChunkId; const isLinkingSource = el.id === linkingSourceChunkId; el.classList.toggle('selected-chunk', isSelected && !linkingMode); el.classList.toggle('linking-source-chunk', isLinkingSource && linkingMode); const linkButton = el.querySelector('.link-chunk-btn'); if (linkButton) { if (isLinkingSource && linkingMode) { linkButton.innerHTML = ICON_LINKING_ACTIVE; linkButton.title = 'Cancel Linking'; linkButton.classList.add('linking-active'); } else { linkButton.innerHTML = ICON_LINK; linkButton.title = 'Add a Relationship'; linkButton.classList.remove('linking-active'); } } }); }
        function selectChunk(chunkId) { selectedChunkId = chunkId; updateSelectedVisuals(); }
        function deselectAllChunks() { const wasLinking = linkingMode; if (wasLinking) { cancelLinkingMode(true); } selectedChunkId = null; if (!wasLinking) { updateSelectedVisuals(); } }
        function createChunkElement(chunkData) {
            const chunkDiv = document.createElement('div');
            chunkDiv.id = chunkData.id; chunkDiv.className = 'chorus-chunk';
            chunkDiv.style.left = chunkData.x + 'px'; chunkDiv.style.top = chunkData.y + 'px'; chunkDiv.style.width = chunkData.width + 'px'; chunkDiv.style.height = chunkData.height + 'px'; chunkDiv.style.zIndex = String(chunkData.zIndex);
            chunkDiv.addEventListener('click', (e) => { const clickedChunkId = chunkData.id; if (linkingMode) { e.stopPropagation(); if (linkingSourceChunkId && linkingSourceChunkId !== clickedChunkId) { completeLink(linkingSourceChunkId, clickedChunkId); } else if (linkingSourceChunkId === clickedChunkId) { if (!e.target.closest('.chunk-action-btn')) { cancelLinkingMode(false); } } return; } const isInteractiveElement = e.target.closest('.chunk-action-btn') || e.target.closest('.chunk-content') || e.target.closest('.resize-handle'); if (!isInteractiveElement) { selectChunk(clickedChunkId); } });
            const header = document.createElement('div'); header.className = 'chunk-header'; header.addEventListener('mousedown', onInteractionStart); header.addEventListener('touchstart', onInteractionStart, { passive: false });
            const headerTitle = document.createElement('span'); headerTitle.className = 'chunk-header-title';
            const actionsContainer = document.createElement('div'); actionsContainer.className = 'chunk-actions';
            
            const aiBtn = document.createElement('button');
            aiBtn.className = 'chunk-action-btn ai-chunk-btn';
            aiBtn.title = 'AI Assistant';
            aiBtn.innerHTML = ICON_AI_SPARKLE;
            const handleAiButtonAction = (e) => { e.preventDefault(); e.stopPropagation(); openAiModal(chunkData.id); };
            aiBtn.addEventListener('click', handleAiButtonAction);
            aiBtn.addEventListener('touchend', handleAiButtonAction);

            const editBtn = document.createElement('button');
            editBtn.className = 'chunk-action-btn edit-chunk-btn';
            editBtn.title = 'Edit Chunk';
            editBtn.innerHTML = ICON_PENCIL_EDIT;
            const handleEditButtonAction = (e) => { e.preventDefault(); e.stopPropagation(); openEditChunkModal(chunkData.id); };
            editBtn.addEventListener('click', handleEditButtonAction);
            editBtn.addEventListener('touchend', handleEditButtonAction);
            
            const linkBtn = document.createElement('button');
            linkBtn.className = 'chunk-action-btn link-chunk-btn';
            linkBtn.innerHTML = ICON_LINK;
            const handleLinkButtonAction = (e) => { e.preventDefault(); e.stopPropagation(); startLinkingMode(chunkData.id); };
            linkBtn.addEventListener('click', handleLinkButtonAction);
            linkBtn.addEventListener('touchend', handleLinkButtonAction);
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'chunk-action-btn delete-chunk-btn';
            deleteBtn.title = 'Delete Chunk';
            deleteBtn.innerHTML = ICON_DELETE;
            const handleDeleteButtonAction = (e) => { e.preventDefault(); e.stopPropagation(); deleteChunk(chunkData.id); };
            deleteBtn.addEventListener('click', handleDeleteButtonAction);
            deleteBtn.addEventListener('touchend', handleDeleteButtonAction);
            
            actionsContainer.appendChild(aiBtn);
            actionsContainer.appendChild(editBtn); 
            actionsContainer.appendChild(linkBtn); 
            actionsContainer.appendChild(deleteBtn);

            header.appendChild(headerTitle); header.appendChild(actionsContainer);
            const content = document.createElement('div'); content.className = 'chunk-content'; content.contentEditable = true; content.innerHTML = chunkData.text;
            content.addEventListener('input', () => { const currentChunkData = chunksMap.get(chunkDiv.id); if (currentChunkData) currentChunkData.text = content.innerHTML; });
            content.addEventListener('focus', () => { highestZIndex++; chunkDiv.style.zIndex = String(highestZIndex); const currentChunkData = chunksMap.get(chunkDiv.id); if (currentChunkData) currentChunkData.zIndex = highestZIndex; if (!linkingMode) selectChunk(chunkData.id); });
            const resizeHandle = document.createElement('div'); resizeHandle.className = 'resize-handle'; resizeHandle.addEventListener('mousedown', onInteractionStart); resizeHandle.addEventListener('touchstart', onInteractionStart, { passive: false });
            chunkDiv.appendChild(header); chunkDiv.appendChild(content); chunkDiv.appendChild(resizeHandle);
            noteCanvas.appendChild(chunkDiv);
            updateChunkHeaderDisplay(chunkData.id); updateSelectedVisuals();
            return chunkDiv;
        }
        function deleteChunk(chunkId) {
            const chunkIndex = chunks.findIndex(c => c.id === chunkId);
            if (chunkIndex > -1) {
                lastDeletedChunk = JSON.parse(JSON.stringify(chunks[chunkIndex]));
                chunks.splice(chunkIndex, 1);
                chunksMap.delete(chunkId);
                chunks.forEach(c => { if (c.links) { c.links = c.links.filter(link => link.targetId !== chunkId); } });
                undoDeleteBtn.disabled = false;
            }
            if (selectedChunkId === chunkId) deselectAllChunks();
            if (linkingSourceChunkId === chunkId) cancelLinkingMode(false);
            const chunkElement = document.getElementById(chunkId);
            if (chunkElement) noteCanvas.removeChild(chunkElement);
            drawConnections();
            updateChunkCounter();
            updateSelectedVisuals();
        }
        function undoDeleteLastChunk() { if (lastDeletedChunk) { if (chunksMap.has(lastDeletedChunk.id)) { showMessage("Undo Failed", "A chunk with the same ID already exists. Cannot undo."); lastDeletedChunk = null; undoDeleteBtn.disabled = true; return; } chunks.push(lastDeletedChunk); chunksMap.set(lastDeletedChunk.id, lastDeletedChunk); createChunkElement(lastDeletedChunk); drawConnections(); selectChunk(lastDeletedChunk.id); lastDeletedChunk = null; undoDeleteBtn.disabled = true; showMessage("Undo Successful", "The last deleted chunk has been restored."); updateChunkCounter(); } else { showMessage("Nothing to Undo", "No chunk deletion to undo."); } }
        function addChunkToCanvas(chunkDetails, options = {}) { const viewportRect = noteCanvasContainer.getBoundingClientRect(); const defaultWorldPos = screenToWorld( (viewportRect.left || 0) + (viewportRect.width || window.innerWidth) / 2, (viewportRect.top || 0) + (viewportRect.height || window.innerHeight) / 4 ); const newChunkData = { id: generateId(), chunkTypeTag: chunkDetails.type.tag, shape: chunkDetails.shape, color: chunkDetails.color, text: options.text || 'New chunk...', x: options.x !== undefined ? options.x : Math.max(0, defaultWorldPos.x), y: options.y !== undefined ? options.y : Math.max(0, defaultWorldPos.y), width: options.width || 250, height: options.height || 140, zIndex: ++highestZIndex, links: [] }; chunks.push(newChunkData); chunksMap.set(newChunkData.id, newChunkData); createChunkElement(newChunkData); selectChunk(newChunkData.id); drawConnections(); updateChunkCounter(); return newChunkData; }

        // --- Linking Logic ---
        function startLinkingMode(sourceId) { linkingMode = true; linkingSourceChunkId = sourceId; document.body.classList.add('linking-mode'); selectedChunkId = sourceId; updateSelectedVisuals(); }
        function cancelLinkingMode(cancelledByDeselectAll = false) { linkingMode = false; const prevSourceId = linkingSourceChunkId; linkingSourceChunkId = null; document.body.classList.remove('linking-mode'); if (cancelledByDeselectAll) { selectedChunkId = null; } else if (prevSourceId) { selectChunk(prevSourceId); } updateSelectedVisuals(); }
        function completeLink(sourceId, targetId) {
            const sourceChunk = chunksMap.get(sourceId);
            if (!sourceChunk) return;
            openLinkEditor(sourceId, targetId);
        }
        function addOrUpdateLink(sourceId, targetId, label, linkType) {
            const sourceChunk = chunksMap.get(sourceId);
            if (sourceChunk) {
                if (!sourceChunk.links) sourceChunk.links = [];
                const existingLink = sourceChunk.links.find(l => l.targetId === targetId);
                if (existingLink) {
                    existingLink.label = label;
                    existingLink.type = linkType;
                } else {
                    sourceChunk.links.push({ targetId, label, type: linkType });
                }
            }
            drawConnections();
            updateSelectedVisuals();
        }
        function getIntersectionPointWithRect(rect, internalPoint, externalPoint) { const p1 = internalPoint; const p2 = externalPoint; const dx = p2.x - p1.x; const dy = p2.y - p1.y; if (dx === 0 && dy === 0) return p1; let tMin = Infinity; let intersection = null; const rectRight = rect.x + rect.width; const rectBottom = rect.y + rect.height; if (dx !== 0) { const t = (rect.x - p1.x) / dx; if (t > 1e-6) { const y = p1.y + t * dy; if (y >= rect.y && y <= rectBottom) { if (t < tMin) { tMin = t; intersection = { x: rect.x, y: y }; } } } } if (dx !== 0) { const t = (rectRight - p1.x) / dx; if (t > 1e-6) { const y = p1.y + t * dy; if (y >= rect.y && y <= rectBottom) { if (t < tMin) { tMin = t; intersection = { x: rectRight, y: y }; } } } } if (dy !== 0) { const t = (rect.y - p1.y) / dy; if (t > 1e-6) { const x = p1.x + t * dx; if (x >= rect.x && x <= rectRight) { if (t < tMin) { tMin = t; intersection = { x: x, y: rect.y }; } } } } if (dy !== 0) { const t = (rectBottom - p1.y) / dy; if (t > 1e-6) { const x = p1.x + t * dx; if (x >= rect.x && x <= rectRight) { if (t < tMin) { tMin = t; intersection = { x: x, y: rectBottom }; } } } } return intersection || p1; }
        let svgDefsCreated = false;
        function ensureSvgDefs() { if (svgDefsCreated) return; const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs'); const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker'); marker.setAttribute('id', 'arrowhead'); marker.setAttribute('viewBox', '0 0 10 10'); marker.setAttribute('refX', '10'); marker.setAttribute('refY', '5'); marker.setAttribute('markerUnits', 'strokeWidth'); marker.setAttribute('markerWidth', '6'); marker.setAttribute('markerHeight', '5'); marker.setAttribute('orient', 'auto'); const path = document.createElementNS('http://www.w3.org/2000/svg', 'path'); path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); path.classList.add('arrow-head'); marker.appendChild(path); defs.appendChild(marker); svgCanvas.appendChild(defs); svgDefsCreated = true; }
        
        function drawConnections() {
            ensureSvgDefs();
            
            const children = Array.from(svgCanvas.children);
            children.forEach(child => {
                if (child.tagName.toLowerCase() !== 'defs') {
                    svgCanvas.removeChild(child);
                }
            });

            chunks.forEach(sourceChunkData => {
                if (sourceChunkData.links && sourceChunkData.links.length > 0) {
                    sourceChunkData.links.forEach(link => {
                        const targetChunkData = chunksMap.get(link.targetId);
                        if (targetChunkData) {
                            const sourceEl = document.getElementById(sourceChunkData.id);
                            const targetEl = document.getElementById(link.targetId);
                            if (sourceEl && targetEl) {
                                const sourceRect = { x: sourceEl.offsetLeft, y: sourceEl.offsetTop, width: sourceEl.offsetWidth, height: sourceEl.offsetHeight };
                                const targetRect = { x: targetEl.offsetLeft, y: targetEl.offsetTop, width: targetEl.offsetWidth, height: targetEl.offsetHeight };
                                const sourceCenter = { x: sourceRect.x + sourceRect.width / 2, y: sourceRect.y + sourceRect.height / 2 };
                                const targetCenter = { x: targetRect.x + targetRect.width / 2, y: targetRect.y + targetRect.height / 2 };
                                if (sourceCenter.x === targetCenter.x && sourceCenter.y === targetCenter.y) return;

                                const startPoint = getIntersectionPointWithRect(sourceRect, sourceCenter, targetCenter);
                                const endPoint = getIntersectionPointWithRect(targetRect, targetCenter, sourceCenter);

                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', String(startPoint.x)); line.setAttribute('y1', String(startPoint.y));
                                line.setAttribute('x2', String(endPoint.x)); line.setAttribute('y2', String(endPoint.y));
                                line.classList.add('connecting-line');

                                const linkType = link.type || 'triggers';
                                line.classList.add(`link-type-${linkType}`);
                                
                                const LIGHT_COLORS_FOR_LINKS = ['White', 'Grey', 'Black'];
                                const sourceColorInfo = COLORS.find(c => c.name === sourceChunkData.color);
                                let linkColor = '#60a5fa'; // Default color
                                if (sourceColorInfo) {
                                    if (LIGHT_COLORS_FOR_LINKS.includes(sourceColorInfo.name)) {
                                        linkColor = '#6b7280'; // Dark grey for contrast
                                    } else {
                                        linkColor = sourceColorInfo.hex;
                                    }
                                }
                                
                                line.style.stroke = linkColor;
                                line.setAttribute('marker-end', 'url(#arrowhead)');
                                svgCanvas.appendChild(line);
                                
                                const arrowHead = svgCanvas.querySelector(`#arrowhead path`);
                                if(arrowHead) arrowHead.style.fill = linkColor;

                                if (link.label) {
                                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                    text.setAttribute('x', String((startPoint.x + endPoint.x) / 2));
                                    text.setAttribute('y', String((startPoint.y + endPoint.y) / 2 - 5));
                                    text.classList.add('link-label');
                                    text.textContent = link.label;
                                    svgCanvas.appendChild(text);
                                }
                            }
                        }
                    });
                }
            });
        }
        
        // --- Unlink Modal Logic ---
        function openUnlinkModal(sourceId) {
            const sourceChunk = chunksMap.get(sourceId);
            if (!sourceChunk || !sourceChunk.links || sourceChunk.links.length === 0) {
                showMessage("No Relationships", "This chunk has no outgoing relationships to manage.");
                return;
            }
            unlinkList.innerHTML = '';
            sourceChunk.links.forEach(link => {
                const targetChunk = chunksMap.get(link.targetId);
                if (targetChunk) {
                    const item = document.createElement('div');
                    item.className = 'flex justify-between items-center p-2 hover:bg-gray-100 rounded-md';
                    let labelText = link.label ? `"${link.label}"` : '(No Note)';
                    item.innerHTML = `<span>To: <strong>${targetChunk.chunkTypeTag}</strong> ${labelText}</span>`;
                    
                    const btnGroup = document.createElement('div');

                    const editBtn = document.createElement('button');
                    editBtn.className = 'btn btn-secondary btn-sm !m-0 mr-2';
                    editBtn.textContent = 'Edit';
                    editBtn.onclick = () => {
                         hideModal(unlinkModal);
                         openLinkEditor(sourceId, link.targetId, link.label, link.type);
                    };

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'btn btn-danger btn-sm !m-0';
                    removeBtn.textContent = 'Remove';
                    removeBtn.onclick = () => {
                        sourceChunk.links = sourceChunk.links.filter(l => l.targetId !== link.targetId);
                        item.remove();
                        drawConnections();
                        updateSelectedVisuals();
                        if (sourceChunk.links.length === 0) {
                            hideModal(unlinkModal);
                        }
                    };
                    btnGroup.appendChild(editBtn);
                    btnGroup.appendChild(removeBtn);
                    item.appendChild(btnGroup);
                    unlinkList.appendChild(item);
                }
            });
            showModal(unlinkModal);
        }

        function openLinkEditor(sourceId, targetId, label = '', linkType = 'triggers') {
            const sourceChunk = chunksMap.get(sourceId);
            if (!sourceChunk) return;

            linkSourceIdInput.value = sourceId;
            linkTargetIdInput.value = targetId;
            linkLabelInput.value = label;
            
            populateSelectWithOptions(linkTypeSelect, LINK_TYPES.map(l => ({value: l.type, text: l.label})), linkType);

            const existingLink = sourceChunk.links.find(l => l.targetId === targetId);
            linkEditTitle.textContent = existingLink ? 'Edit Relationship' : 'Create Relationship';
            confirmLinkEditBtn.textContent = existingLink ? 'Save Changes' : 'Create Link';
            
            showModal(linkEditModal);
        }

        // --- Interaction Logic (Drag, Resize, Pan, Zoom) ---
        function onInteractionStart(e) {
            const isTouchEvent = e.type.startsWith('touch');

            // If in linking mode, we want a tap to complete the link, not start a drag.
            if (linkingMode) {
                // On touch devices, sometimes a "tap" doesn't fire a clean click event if there's
                // a tiny movement, so we handle it on touchstart directly to be more reliable.
                if (isTouchEvent) {
                     e.preventDefault();
                     e.stopPropagation(); // Prevent any other listeners from firing.
                     const targetChunk = e.target.closest('.chorus-chunk');
                     if (targetChunk) {
                        const targetChunkId = targetChunk.id;
                         if (linkingSourceChunkId && linkingSourceChunkId !== targetChunkId) {
                            completeLink(linkingSourceChunkId, targetChunkId);
                        } else if (linkingSourceChunkId === targetChunkId) {
                            // Tapped on the source chunk again, cancel linking.
                            if (!e.target.closest('.chunk-action-btn')) {
                                cancelLinkingMode(false);
                            }
                        }
                     }
                }
                // For mouse clicks, we just return and let the `click` event on the chunk handle it.
                return;
            }
            
            if (isTouchEvent && e.touches.length > 1) return; 
            if (isTouchEvent) e.preventDefault(); 
            const pointer = getPointerCoordinates(e); 
            interactionStartX = pointer.x; 
            interactionStartY = pointer.y; 
            if (e.target.classList.contains('resize-handle')) { 
                currentAction = 'resize'; 
                resizingChunk = e.target.closest('.chorus-chunk'); 
                if (!resizingChunk) { currentAction = null; return; } 
                e.stopPropagation(); 
                selectChunk(resizingChunk.id); 
                highestZIndex++; resizingChunk.style.zIndex = String(highestZIndex); 
                const chunkData = chunksMap.get(resizingChunk.id); 
                if(chunkData) chunkData.zIndex = highestZIndex; 
                startX = pointer.x; startY = pointer.y; 
                startWidth = parseFloat(resizingChunk.style.width); 
                startHeight = parseFloat(resizingChunk.style.height); 
            } else if (e.target.closest('.chunk-header')) { 
                if (e.target.closest('.chunk-action-btn')) return; 
                currentAction = 'drag'; 
                draggedChunk = e.target.closest('.chorus-chunk'); 
                if (!draggedChunk) { currentAction = null; return; } 
                e.stopPropagation(); 
                selectChunk(draggedChunk.id); 
                highestZIndex++; 
                draggedChunk.style.zIndex = String(highestZIndex); 
                const chunkData = chunksMap.get(draggedChunk.id); 
                if(chunkData) chunkData.zIndex = highestZIndex; 
                const worldPointer = screenToWorld(pointer.x, pointer.y); 
                offsetX = worldPointer.x - parseFloat(draggedChunk.style.left); 
                offsetY = worldPointer.y - parseFloat(draggedChunk.style.top); 
            } 
            if (currentAction === 'drag' || currentAction === 'resize') { 
                document.addEventListener('mousemove', onInteractionMove); 
                document.addEventListener('mouseup', onInteractionEnd); 
                document.addEventListener('touchmove', onInteractionMove, { passive: false }); 
                document.addEventListener('touchend', onInteractionEnd); 
            } 
        }
        let interactionMoveQueued = false;
        function onInteractionMove(e) { const isTouchEvent = e.type.startsWith('touch'); if (!currentAction) return; if (isTouchEvent) e.preventDefault(); if (interactionMoveQueued) return; interactionMoveQueued = true; requestAnimationFrame(() => { const pointer = getPointerCoordinates(e); if (currentAction === 'drag' && draggedChunk) { const worldPointer = screenToWorld(pointer.x, pointer.y); let newWorldX = worldPointer.x - offsetX; let newWorldY = worldPointer.y - offsetY; const canvasWorldWidth = noteCanvas.scrollWidth; const canvasWorldHeight = noteCanvas.scrollHeight; const chunkWidth = parseFloat(draggedChunk.style.width); const chunkHeight = parseFloat(draggedChunk.style.height); newWorldX = Math.max(0, Math.min(newWorldX, canvasWorldWidth - chunkWidth)); newWorldY = Math.max(0, Math.min(newWorldY, canvasWorldHeight - chunkHeight)); draggedChunk.style.left = newWorldX + 'px'; draggedChunk.style.top = newWorldY + 'px'; drawConnections(); } else if (currentAction === 'resize' && resizingChunk) { const deltaScreenX = pointer.x - startX; const deltaScreenY = pointer.y - startY; let newWidth = startWidth + (deltaScreenX / scale); let newHeight = startHeight + (deltaScreenY / scale); newWidth = Math.max(240, newWidth); newHeight = Math.max(140, newHeight); const chunkCurrentX = parseFloat(resizingChunk.style.left); const chunkCurrentY = parseFloat(resizingChunk.style.top); const canvasWorldWidth = noteCanvas.scrollWidth; const canvasWorldHeight = noteCanvas.scrollHeight; if (chunkCurrentX + newWidth > canvasWorldWidth) newWidth = canvasWorldWidth - chunkCurrentX; if (chunkCurrentY + newHeight > canvasWorldHeight) newHeight = canvasWorldHeight - chunkCurrentY; resizingChunk.style.width = newWidth + 'px'; resizingChunk.style.height = newHeight + 'px'; drawConnections(); } else if (currentAction === 'pan') { translateX = pointer.x - panStartX; translateY = pointer.y - panStartY; applyTransform(); } interactionMoveQueued = false; }); }
        function onInteractionEnd(e) { if (currentAction === 'drag' && draggedChunk) { const chunkData = chunksMap.get(draggedChunk.id); if (chunkData) { chunkData.x = parseFloat(draggedChunk.style.left); chunkData.y = parseFloat(draggedChunk.style.top); } draggedChunk = null; } else if (currentAction === 'resize' && resizingChunk) { const chunkData = chunksMap.get(resizingChunk.id); if (chunkData) { chunkData.width = parseFloat(resizingChunk.style.width); chunkData.height = parseFloat(resizingChunk.style.height); } resizingChunk = null; } else if (currentAction === 'pan') { noteCanvasContainer.classList.remove('panning'); } if (currentAction !== 'pinch-zoom') { currentAction = null; } document.removeEventListener('mousemove', onInteractionMove); document.removeEventListener('mouseup', onInteractionEnd); document.removeEventListener('touchmove', onInteractionMove); document.removeEventListener('touchend', onInteractionEnd); }
        
        // --- Save/Load & Export ---
        function saveCanvasAsTemplate() {
            if (chunks.length === 0) {
                showMessage("Empty Canvas", "There is nothing on the canvas to save as a template.");
                return;
            }
            
            // Deep copy and update text from contentEditable
            let templateChunks = JSON.parse(JSON.stringify(chunks));
            templateChunks.forEach(chunkData => {
                const chunkElement = document.getElementById(chunkData.id);
                if (chunkElement) {
                    const contentDiv = chunkElement.querySelector('.chunk-content');
                    if (contentDiv) chunkData.text = contentDiv.innerHTML;
                }
            });

            // Normalize coordinates
            let minX = Infinity;
            let minY = Infinity;
            templateChunks.forEach(chunk => {
                minX = Math.min(minX, chunk.x);
                minY = Math.min(minY, chunk.y);
            });
            
            templateChunks.forEach(chunk => {
                chunk.x -= minX;
                chunk.y -= minY;
            });

            const templateData = {
                name: "Custom Template",
                description: "A template saved from the canvas.",
                chunks: templateChunks,
                links: [] // Links are embedded in chunks now
            };

            // Re-map links to use internal IDs, not generated ones
            const idMap = new Map();
            templateChunks.forEach((chunk, index) => {
                const oldId = chunk.id;
                const newId = `template_chunk_${index}`;
                idMap.set(oldId, newId);
                chunk.id = newId;
            });

            templateChunks.forEach(chunk => {
                if(chunk.links) {
                    chunk.links.forEach(link => {
                        link.targetId = idMap.get(link.targetId);
                    });
                    // Filter out any links that didn't get re-mapped
                    chunk.links = chunk.links.filter(link => link.targetId);
                }
            });
            
            // Re-embed links in the template structure
            templateData.links = [];
            templateChunks.forEach(chunk => {
                if(chunk.links) {
                    chunk.links.forEach(link => {
                        templateData.links.push({
                            from: chunk.id,
                            to: link.targetId,
                            label: link.label,
                            type: link.type
                        });
                    });
                }
            });


            const dataStr = JSON.stringify(templateData, null, 2);
            downloadFile(dataStr, 'chorus-template.chtml', 'application/json');
            showMessage('Template Saved', 'Your custom template has been prepared for download.');
        }

        function saveDataToFile() { chunks.forEach(chunkData => { const chunkElement = document.getElementById(chunkData.id); if (chunkElement) { const contentDiv = chunkElement.querySelector('.chunk-content'); if (contentDiv) { chunkData.text = contentDiv.innerHTML; } } }); if (chunks.length === 0) { showMessage("Empty Board", "There are no notes to save."); return; } try { const dataToSave = { chunks: chunks, viewport: { scale: scale, translateX: translateX, translateY: translateY } }; const dataStr = JSON.stringify(dataToSave, null, 2); downloadFile(dataStr, 'chorus-perceptual-map.json', 'application/json'); showMessage('Saved to File', 'Your board has been prepared for download.'); } catch (error) { showMessage('Save Error', `Could not prepare data for saving: ${error.message}`); console.error("Save error:", error); } }
        function downloadFile(content, fileName, contentType) { const a = document.createElement('a'); const file = new Blob([content], {type: contentType}); a.href = URL.createObjectURL(file); a.download = fileName; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href); }
        
        function exportTo(format) {
            let content = '';
            let fileExt = '';
            let mimeType = 'text/plain';

            const tempDiv = document.createElement('div');
            function cleanText(html) {
                tempDiv.innerHTML = html.replace(/<br\s*[\/]?>/gi, "\n").replace(/<p>/gi, "").replace(/<\/p>/gi, "\n\n");
                return (tempDiv.textContent || tempDiv.innerText || "").trim();
            }

            function escapeForRenpy(text) {
                return text.replace(/"/g, '\\"').replace(/\n/g, '\\n');
            }
            
            chunks.forEach(chunkData => {
                 const chunkElement = document.getElementById(chunkData.id);
                 if (chunkElement) {
                     const contentDiv = chunkElement.querySelector('.chunk-content');
                     if(contentDiv) chunkData.text = contentDiv.innerHTML;
                 }
            });

            if (format === 'json') {
                content = JSON.stringify({ chunks: chunks }, null, 2);
                fileExt = 'json';
                mimeType = 'application/json';
            } else if (format === 'narrative-txt') {
                fileExt = 'txt';
                mimeType = 'text/plain;charset=utf-8';
                const formatTypeTagForNarrative = (tag) => {
                    const descriptiveText = tag.replace('#', '').replace(/-/g, ' ');
                    const article = /^[aeiou]/i.test(descriptiveText) ? 'An' : 'A';
                    return `${article} ${descriptiveText}.`;
                };
                chunks.forEach((chunk, index) => {
                    const shapeInfo = SHAPES.find(s => s.name === chunk.shape) || { essence: 'not specified' };
                    const colorInfo = COLORS.find(c => c.name === chunk.color) || { essence: 'not specified' };
                    content += `--- SECTION ${index + 1} (${chunk.chunkTypeTag}) ---\n\n`;
                    content += `${formatTypeTagForNarrative(chunk.chunkTypeTag)}\n\n`;
                    content += `${cleanText(chunk.text)}\n\n`;
                    content += `(This moment is perceived as a functional '${shapeInfo.essence.toLowerCase()}' with an emotional tone of '${colorInfo.essence.toLowerCase()}'.)\n\n`;
                    if (chunk.links && chunk.links.length > 0) {
                        content += 'From here, the story continues:\n';
                        chunk.links.forEach(link => {
                            const target = chunksMap.get(link.targetId);
                            const linkTypeInfo = LINK_TYPES.find(lt => lt.type === link.type) || { label: link.type };
                            let linkDescription = link.label || linkTypeInfo.label;
                            if (target) {
                                const targetIndex = chunks.findIndex(c => c.id === target.id);
                                if (targetIndex !== -1) {
                                    content += `  - ${linkDescription}. (Continue to SECTION ${targetIndex + 1})\n`;
                                } else {
                                    content += `  - ${linkDescription}, but the destination is missing.\n`;
                                }
                            } else {
                                 content += `  - ${linkDescription}, leading to an unknown destination.\n`;
                            }
                        });
                        content += `\n`;
                    } else {
                        content += 'This is the end of this path.\n\n';
                    }
                    content += `------------------------------------------\n\n`;
                });
            } else if (format === 'yarn') {
                fileExt = 'yarn';
                chunks.forEach(chunk => {
                    content += `title: ${chunk.id}\n`;
                    content += `tags: ${chunk.chunkTypeTag.replace('#','')} ${chunk.shape} ${chunk.color}\n`;
                    content += `---\n`;
                    content += `${cleanText(chunk.text)}\n`;
                    if (chunk.links) {
                        chunk.links.forEach(link => {
                            let linkText = link.label || `Continue (${link.type})`;
                            content += `[[${linkText}|${link.targetId}]]\n`;
                        });
                    }
                    content += `===\n`;
                });
            } else if (format === 'twee') {
                 fileExt = 'twee';
                 chunks.forEach(chunk => {
                    content += `:: ${chunk.id} [${chunk.chunkTypeTag.replace('#','')} ${chunk.shape} ${chunk.color}]\n`;
                    content += `${cleanText(chunk.text)}\n`;
                    if (chunk.links) {
                        chunk.links.forEach(link => {
                            let linkText = link.label || `Continue (${link.type})`;
                            content += `[[${linkText}->${link.targetId}]]\n`;
                        });
                    }
                    content += `\n`;
                });
            } else if (format === 'ink') {
                fileExt = 'ink';
                chunks.forEach(chunk => {
                    content += `=== ${chunk.id} ===\n`;
                    content += `${cleanText(chunk.text)}\n`;
                    if (chunk.links && chunk.links.length > 0) {
                        chunk.links.forEach(link => {
                            let linkText = link.label || `Continue (${link.type})`;
                            content += `* ${linkText} -> ${link.targetId}\n`;
                        });
                    } else {
                        content += '-> END\n';
                    }
                     content += `\n`;
                });
            } else if (format === 'renpy') {
                fileExt = 'rpy';
                content += 'label start:\n';
                const firstChunk = chunks.find(c => c.links.length > 0 && !chunks.some(other => other.links.some(l => l.targetId === c.id))) || chunks[0];
                if (firstChunk) {
                    content += `    jump ${firstChunk.id}\n\n`;
                }

                chunks.forEach(chunk => {
                    content += `label ${chunk.id}:\n`;
                    content += `    " ${escapeForRenpy(cleanText(chunk.text))} "\n`;
                    if (chunk.links && chunk.links.length > 0) {
                        content += '    menu:\n';
                        chunk.links.forEach(link => {
                            let linkText = escapeForRenpy(link.label || `Continue (${link.type})`);
                            content += `        "${linkText}":\n`;
                            content += `            jump ${link.targetId}\n`;
                        });
                    } else {
                        content += '    "The end."\n';
                        content += '    return\n';
                    }
                    content += '\n';
                });
            } else if (format === 'i7') {
                fileExt = 'ni';
                content = `Volume - CHORUS Export\n\n`;
                content += `Book - Story\n\n`;
                
                chunks.forEach(chunk => {
                    let roomName = `${chunk.chunkTypeTag.replace('#','')} (${chunk.id.substring(0,5)})`.replace(/-/g, ' ');
                    content += `"${roomName}" is a room. "${cleanText(chunk.text)}".\n\n`;
                });

                chunks.forEach(chunk => {
                     if (chunk.links && chunk.links.length > 0) {
                         let sourceRoomName = `${chunk.chunkTypeTag.replace('#','')} (${chunk.id.substring(0,5)})`.replace(/-/g, ' ');
                         chunk.links.forEach(link => {
                             const targetChunk = chunksMap.get(link.targetId);
                             if (targetChunk) {
                                let targetRoomName = `${targetChunk.chunkTypeTag.replace('#','')} (${targetChunk.id.substring(0,5)})`.replace(/-/g, ' ');
                                let direction = `The path labeled "${link.label || link.type}"`;
                                content += `${direction} leads to "${targetRoomName}" from "${sourceRoomName}".\n`;
                             }
                         });
                         content += '\n';
                     }
                });

            } else if (format === 'txt') {
                fileExt = 'txt';
                chunks.forEach(chunk => {
                    content += `--- CHUNK: ${chunk.id} ---\n`;
                    content += `Type: ${chunk.chunkTypeTag} | Shape: ${chunk.shape} | Color: ${chunk.color}\n\n`;
                    content += `${cleanText(chunk.text)}\n\n`;
                    if (chunk.links && chunk.links.length > 0) {
                        content += 'Relationships:\n';
                        chunk.links.forEach(link => {
                            const target = chunksMap.get(link.targetId);
                            const linkInfo = LINK_TYPES.find(lt => lt.type === link.type) || {label: link.type};
                            content += `  -> ${linkInfo.label} to: ${target ? target.chunkTypeTag : 'Unknown'} (${link.targetId})\n`;
                            if(link.label) content += `     Note: "${link.label}"\n`;
                        });
                    }
                    content += `\n\n`;
                });
            }
            if(content) {
                downloadFile(content, `chorus-export.${fileExt}`, mimeType);
            }
        }

        function renderBoard(loadedChunksData) {
            const existingChunkElements = noteCanvas.querySelectorAll('.chorus-chunk'); existingChunkElements.forEach(el => el.remove());
            chunks = loadedChunksData || []; chunksMap.clear(); highestZIndex = 0; selectedChunkId = null; lastDeletedChunk = null; undoDeleteBtn.disabled = true; cancelLinkingMode(true);
            if (Array.isArray(chunks)) { chunks.forEach(chunkData => { chunkData.links = chunkData.links || []; if (chunkData && chunkData.id && chunkData.chunkTypeTag) { chunksMap.set(chunkData.id, chunkData); createChunkElement(chunkData); if (chunkData.zIndex > highestZIndex) { highestZIndex = chunkData.zIndex; } } else { console.warn("Skipping invalid chunk data during render:", chunkData); } }); }
            if(chunks.length === 0) highestZIndex = 1;
            updateSelectedVisuals(); drawConnections(); updateChunkCounter();
        }

        function openEditChunkModal(chunkId) {
            const chunkData = chunksMap.get(chunkId);
            if (!chunkData) return;
            editingChunkIdInput.value = chunkId;
            populateSelectWithOptions(editChunkTypeSelect, null, chunkData.chunkTypeTag, chunkTypes, key => key.charAt(0).toUpperCase() + key.slice(1) + " Types");
            populateSelectWithOptions(editChunkShapeSelect, SHAPES.map(s => ({value: s.name, text: `${s.symbol} ${s.name} - ${s.essence}`})), chunkData.shape);
            populateSelectWithOptions(editChunkColorSelect, COLORS.map(c => ({value: c.name, text: `${c.symbol} ${c.name} - ${c.essence}`})), chunkData.color);

            const actionsDiv = document.getElementById('editModalActions');
            let manageBtn = document.getElementById('manageLinksBtn');
            if (!manageBtn) {
                manageBtn = document.createElement('button');
                manageBtn.id = 'manageLinksBtn';
                manageBtn.className = 'btn btn-secondary';
                manageBtn.textContent = 'Manage Relationships';
                actionsDiv.insertBefore(manageBtn, cancelEditChunkBtn);
            }
            manageBtn.onclick = () => {
                hideModal(editChunkModal);
                openUnlinkModal(chunkData.id);
            };

            showModal(editChunkModal);
        }

        // --- Initialization Sequence ---
        function initializeApp() {
            document.getElementById('copyrightYear').textContent = new Date().getFullYear();
            
            loadApiKey();
            loadCustomChunkTypes(); 
            setupTemplateModal(); 
            populateAddChunkModal();
            renderBoard([]);
            
            // Add all event listeners
            addChunkBtn.addEventListener('click', () => { if(linkingMode) cancelLinkingMode(false); showModal(addChunkModal); });
            templatesBtn.addEventListener('click', () => showModal(templatesModal));
            clearCanvasBtn.addEventListener('click', () => { if (linkingMode) cancelLinkingMode(false); if (chunks.length === 0) { showMessage("Canvas Empty", "The canvas is already clear."); return; } showMessage("Confirm Clear", "Are you sure you want to clear the entire canvas? This action cannot be undone.", [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Clear Canvas', class: 'btn-danger', action: () => { renderBoard([]); showMessage("Canvas Cleared", "All notes and links have been removed."); }} ]); });
            undoDeleteBtn.addEventListener('click', () => { if (linkingMode) cancelLinkingMode(false); undoDeleteLastChunk(); });
            saveBtn.addEventListener('click', saveDataToFile);
            loadBtn.addEventListener('click', () => { if(linkingMode) cancelLinkingMode(false); if (chunks.length > 0) { showMessage("Confirm Load", "Loading a new file will clear any unsaved changes on the current canvas. Are you sure you want to proceed?", [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Load File', class: 'btn-primary', action: () => fileLoadInput.click() } ]); } else { fileLoadInput.click(); } });
            settingsBtn.addEventListener('click', () => showModal(settingsModal));
            helpBtn.addEventListener('click', () => { if(linkingMode) cancelLinkingMode(false); showModal(helpModal); });
            
            exportJsonBtn.addEventListener('click', () => exportTo('json'));
            exportYarnBtn.addEventListener('click', () => exportTo('yarn'));
            exportTweeBtn.addEventListener('click', () => exportTo('twee'));
            exportTxtBtn.addEventListener('click', () => exportTo('txt'));
            exportNarrativeTxtBtn.addEventListener('click', () => exportTo('narrative-txt'));
            exportInkBtn.addEventListener('click', () => exportTo('ink'));
            exportRenpyBtn.addEventListener('click', () => exportTo('renpy'));
            exportI7Btn.addEventListener('click', () => exportTo('i7'));
            exportArticyBtn.addEventListener('click', () => {
                showMessage("articy:draft Export", "Direct export to articy:draft is not supported due to its complex project format. To get your data into articy, you would typically use its API or import an XML/JSON file with a specific structure.<br><br>As an alternative, please use the <strong>JSON export</strong> option. You can then use that JSON data with a custom script to import it into your articy:draft project.");
            });


            saveCanvasAsTemplateBtn.addEventListener('click', saveCanvasAsTemplate);
            loadCustomTemplateBtn.addEventListener('click', () => templateLoadInput.click());

            cancelAddChunkBtn.addEventListener('click', () => hideModal(addChunkModal));
            confirmAddChunkBtn.addEventListener('click', () => { 
                const selectedType = allChunkTypesList.find(ct => ct.tag === chunkTypeSelect.value); 
                const selectedShapeName = addChunkShapeSelect.value;
                const selectedColorName = addChunkColorSelect.value;
                if (!selectedType) { showMessage('Error', 'Please make a selection for chunk type.'); return; } 
                addChunkToCanvas({ type: selectedType, shape: selectedShapeName, color: selectedColorName }); 
                hideModal(addChunkModal); 
            });
            cancelEditChunkBtn.addEventListener('click', () => hideModal(editChunkModal));
            confirmEditChunkBtn.addEventListener('click', () => { const chunkId = editingChunkIdInput.value; const chunkData = chunksMap.get(chunkId); if (!chunkData) return; const newType = allChunkTypesList.find(ct => ct.tag === editChunkTypeSelect.value); const newShapeName = editChunkShapeSelect.value; const newColorName = editChunkColorSelect.value; if (!newType || !newShapeName || !newColorName) { showMessage('Error', 'Invalid selection.'); return; } chunkData.chunkTypeTag = newType.tag; chunkData.shape = newShapeName; chunkData.color = newColorName; updateChunkHeaderDisplay(chunkId); hideModal(editChunkModal); updateSelectedVisuals(); drawConnections(); });
            closeHelpBtn.addEventListener('click', () => hideModal(helpModal));
            closeHelpModalSpan.addEventListener('click', () => hideModal(helpModal));
            closeUnlinkModalBtn.addEventListener('click', () => hideModal(unlinkModal));
            cancelLinkEditBtn.addEventListener('click', () => { hideModal(linkEditModal); cancelLinkingMode(false); });
            confirmLinkEditBtn.addEventListener('click', () => {
                const sourceId = linkSourceIdInput.value;
                const targetId = linkTargetIdInput.value;
                const label = linkLabelInput.value;
                const type = linkTypeSelect.value;
                addOrUpdateLink(sourceId, targetId, label, type);
                hideModal(linkEditModal);
                cancelLinkingMode(false);
            });
            fileLoadInput.addEventListener('change', (event) => { const file = event.target.files[0]; if (!file) return; if (file.type !== "application/json") { showMessage("Load Error", "Invalid file type. Please select a .json file."); event.target.value = null; return; } const reader = new FileReader(); reader.onload = (e) => { try { const loadedData = JSON.parse(e.target.result); if (loadedData && Array.isArray(loadedData.chunks)) { renderBoard(loadedData.chunks); if (loadedData.viewport) { scale = loadedData.viewport.scale || 1; translateX = loadedData.viewport.translateX || 0; translateY = loadedData.viewport.translateY || 0; applyTransform(); } else { resetAndCenterView(); } showMessage('Loaded from File', `Successfully loaded notes from ${file.name}.`); } else { throw new Error("Invalid file format. Expected 'chunks' array."); } } catch (error) { showMessage('Load Error', `Could not load or parse file: ${error.message}.`); console.error("Load error:", error); } finally { event.target.value = null; } }; reader.onerror = () => { showMessage('Load Error', `Error reading file: ${reader.error}`); event.target.value = null; console.error("File read error:", reader.error); }; reader.readAsText(file); });
            templateLoadInput.addEventListener('change', (event) => { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { try { const templateData = JSON.parse(e.target.result); if (templateData && Array.isArray(templateData.chunks)) { showMessage("Confirm Load Template", `This will clear the current canvas. Are you sure you want to load the template "${file.name}"?`, [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Load Template', class: 'btn-primary', action: () => { loadTemplate(templateData); hideModal(templatesModal); } } ]); } else { throw new Error("Invalid template file format."); } } catch (error) { showMessage('Load Error', `Could not load or parse template file: ${error.message}.`); console.error("Load error:", error); } finally { event.target.value = null; } }; reader.onerror = () => { showMessage('Load Error', `Error reading template file: ${reader.error}`); event.target.value = null; }; reader.readAsText(file); });
            
            // Settings and AI Listeners
            closeSettingsModalBtn.addEventListener('click', () => hideModal(settingsModal));
            saveSettingsBtn.addEventListener('click', () => { saveApiKey(); hideModal(settingsModal); });
            aiActionDeepenBtn.addEventListener('click', handleDeepenSensoryDetails);
            aiActionInternalStateBtn.addEventListener('click', handleExploreInternalState);
            aiActionSuggestEchoBtn.addEventListener('click', handleSuggestEcho);

            // Zoom Listeners
            const getViewportCenterForZoom = () => {
                const rect = noteCanvasContainer.getBoundingClientRect();
                return { x: rect.width / 2, y: rect.height / 2 };
            };
            zoomInBtn.addEventListener('click', () => {
                const center = getViewportCenterForZoom();
                zoomAtPoint(scale * 1.25, center.x, center.y);
            });
            zoomOutBtn.addEventListener('click', () => {
                const center = getViewportCenterForZoom();
                zoomAtPoint(scale / 1.25, center.x, center.y);
            });
            zoomResetBtn.addEventListener('click', () => {
                 resetAndCenterView();
            });

            // Canvas and keyboard listeners
            noteCanvasContainer.addEventListener('mousedown', (e) => { if (e.target === noteCanvasContainer || e.target === transformContainer || e.target === noteCanvas) { if (linkingMode) { deselectAllChunks(); return; } currentAction = 'pan'; const pointer = getPointerCoordinates(e); panStartX = pointer.x - translateX; panStartY = pointer.y - translateY; noteCanvasContainer.classList.add('panning'); document.addEventListener('mousemove', onInteractionMove); document.addEventListener('mouseup', onInteractionEnd); } else if (!e.target.closest('.chorus-chunk') && !e.target.closest('.toolbar') && !e.target.closest('.modal')) { deselectAllChunks(); } });
            noteCanvasContainer.addEventListener('touchstart', (e) => { if (e.target === noteCanvasContainer || e.target === transformContainer || e.target === noteCanvas) { if (e.touches.length === 1) { if (linkingMode) { deselectAllChunks(); e.preventDefault(); return; } e.preventDefault(); currentAction = 'pan'; const pointer = getPointerCoordinates(e); panStartX = pointer.x - translateX; panStartY = pointer.y - translateY; noteCanvasContainer.classList.add('panning'); document.addEventListener('touchmove', onInteractionMove, { passive: false }); document.addEventListener('touchend', onInteractionEnd); } else if (e.touches.length === 2) { e.preventDefault(); currentAction = 'pinch-zoom'; noteCanvasContainer.classList.remove('panning'); const t1 = { x: e.touches[0].clientX, y: e.touches[0].clientY }; const t2 = { x: e.touches[1].clientX, y: e.touches[1].clientY }; initialPinchDistance = Math.hypot(t1.x - t2.x, t1.y - t2.y); } }  else if (!e.target.closest('.chorus-chunk') && !e.target.closest('.toolbar') && !e.target.closest('.modal')) { deselectAllChunks(); e.preventDefault(); } }, { passive: false });
            noteCanvasContainer.addEventListener('wheel', (e) => { e.preventDefault(); const rect = noteCanvasContainer.getBoundingClientRect(); const mouseX = e.clientX - (rect.left || 0); const mouseY = e.clientY - (rect.top || 0); const delta = e.deltaY * ZOOM_SENSITIVITY * -1; const newScale = scale * (1 + delta); zoomAtPoint(newScale, mouseX, mouseY); }, { passive: false });
            noteCanvasContainer.addEventListener('touchmove', (e) => { if (currentAction === 'pinch-zoom' && e.touches.length === 2) { e.preventDefault(); const t1 = { x: e.touches[0].clientX, y: e.touches[0].clientY }; const t2 = { x: e.touches[1].clientX, y: e.touches[1].clientY }; const currentPinchDistance = Math.hypot(t1.x - t2.x, t1.y - t2.y); const pinchMidpointScreen = { x: (t1.x + t2.x) / 2, y: (t1.y + t2.y) / 2 }; if (initialPinchDistance === null) { initialPinchDistance = currentPinchDistance; return; } const rect = noteCanvasContainer.getBoundingClientRect(); const worldMidXBeforeZoom = (pinchMidpointScreen.x - (rect.left || 0) - translateX) / scale; const worldMidYBeforeZoom = (pinchMidpointScreen.y - (rect.top || 0) - translateY) / scale; let scaleChange = currentPinchDistance / initialPinchDistance; let newScale = scale * scaleChange; newScale = Math.max(MIN_SCALE, Math.min(newScale, MAX_SCALE)); translateX = (pinchMidpointScreen.x - (rect.left || 0)) - worldMidXBeforeZoom * newScale; translateY = (pinchMidpointScreen.y - (rect.top || 0)) - worldMidYBeforeZoom * newScale; scale = newScale; applyTransform(); initialPinchDistance = currentPinchDistance; } }, { passive: false });
            noteCanvasContainer.addEventListener('touchend', (e) => { if (e.touches.length < 2 && currentAction === 'pinch-zoom') { initialPinchDistance = null; currentAction = null; } });
            document.addEventListener('keydown', (e) => { const activeEl = document.activeElement; const isInputFocused = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable); const isCtrlOrCmd = e.ctrlKey || e.metaKey; let shortcutHandled = false; if (isCtrlOrCmd) { switch (e.key.toLowerCase()) { case 's': saveBtn.click(); shortcutHandled = true; break; case 'o': loadBtn.click(); shortcutHandled = true; break; case 'z': if (!undoDeleteBtn.disabled) { undoDeleteBtn.click(); shortcutHandled = true; } break; } } if(shortcutHandled){ e.preventDefault(); return; } if (isInputFocused) { if (e.key === 'Escape') { activeEl.blur(); } return; } switch(e.key){ case 'Escape': if (!addChunkModal.classList.contains('hidden')) { hideModal(addChunkModal); } else if (!editChunkModal.classList.contains('hidden')) { hideModal(editChunkModal); } else if (!helpModal.classList.contains('hidden')) { hideModal(helpModal); } else if (!messageModal.classList.contains('hidden')) { hideModal(messageModal); } else if (!settingsModal.classList.contains('hidden')) { hideModal(settingsModal); } else if (!aiActionModal.classList.contains('hidden')) { hideModal(aiActionModal); } else if (linkingMode) { cancelLinkingMode(false); } else if (selectedChunkId) { deselectAllChunks(); } shortcutHandled = true; break; case 'Delete': case 'Backspace': if (selectedChunkId) { showMessage("Confirm Delete", `Are you sure you want to delete the selected chunk (${chunksMap.get(selectedChunkId)?.chunkTypeTag || 'chunk'})?`, [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Delete', class: 'btn-danger', action: () => { deleteChunk(selectedChunkId); }} ]); shortcutHandled = true; } break; case 'a': case 'A': addChunkBtn.click(); shortcutHandled = true; break; case '?': case '/': helpBtn.click(); shortcutHandled = true; break; case '+': case '=': zoomInBtn.click(); shortcutHandled = true; break; case '-': case '_': zoomOutBtn.click(); shortcutHandled = true; break; } if(shortcutHandled){ e.preventDefault(); } });

            // Final setup
            let resizeQueued = false;
            window.addEventListener('resize', () => { if (resizeQueued) return; resizeQueued = true; requestAnimationFrame(() => { const toolbarElement = document.querySelector('.toolbar'); const footerElement = document.querySelector('footer'); let toolbarHeight = toolbarElement ? toolbarElement.offsetHeight : 0; let footerHeight = footerElement ? footerElement.offsetHeight : 0; if (mainContent) { mainContent.style.height = `calc(100vh - ${toolbarHeight}px - ${footerHeight}px)`; } applyTransform(); resizeQueued = false; }); });
            window.dispatchEvent(new Event('resize'));
            resetAndCenterView();
            window.addEventListener('beforeunload', (event) => { if (chunks.length > 0) { event.preventDefault(); event.returnValue = ''; return ''; } });
            
            const exportBtn = document.getElementById('exportBtn');
            const exportDropdownContent = document.getElementById('exportDropdownContent');

            exportBtn.addEventListener('click', (event) => {
                event.stopPropagation();
                exportDropdownContent.classList.toggle('show');
            });

            exportDropdownContent.addEventListener('click', () => {
                 exportDropdownContent.classList.remove('show');
            });
            
            window.addEventListener('click', (event) => {
                if (exportDropdownContent.classList.contains('show') && !exportBtn.contains(event.target)) {
                    exportDropdownContent.classList.remove('show');
                }
            });


            setTimeout(() => { document.getElementById('noteCanvasContainer').focus(); }, 100);
            
            console.log("CHORUS: Perceptual Storyteller Initialized");
        }
        initializeApp();
    });
    </script>
</body>
</html>
